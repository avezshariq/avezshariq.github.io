{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"My Stories (Blog Home) Welcome! This is where code meets craft. While many developers stop at the \" how \", I'm obsessed with the \" why \" \u2014 and I've found that the best way to explain complex systems is to... well... show them I've always found that a good diagram can do more than a wall of text. Because I work with vector graphics, I aim to explain complex concepts using illustrations to make the details easier to follow. Whether you're here to solve a specific problem or just to see how things work under the hood, I hope these visual breakdowns help Useful links Portfolio Site \ud83e\uddd4\ud83c\udffb\u200d\u2642\ufe0f About \ud83d\udcdc Projects \ud83e\uddbe","title":"My Stories (Blog Home)"},{"location":"#my-stories-blog-home","text":"Welcome! This is where code meets craft. While many developers stop at the \" how \", I'm obsessed with the \" why \" \u2014 and I've found that the best way to explain complex systems is to... well... show them I've always found that a good diagram can do more than a wall of text. Because I work with vector graphics, I aim to explain complex concepts using illustrations to make the details easier to follow. Whether you're here to solve a specific problem or just to see how things work under the hood, I hope these visual breakdowns help","title":"My Stories (Blog Home)"},{"location":"#useful-links","text":"Portfolio Site \ud83e\uddd4\ud83c\udffb\u200d\u2642\ufe0f About \ud83d\udcdc Projects \ud83e\uddbe","title":"Useful links"},{"location":"2026_02_26/","text":"Copying in Python (WIP) Motivation \ud83d\udcaa\ud83c\udffb Lets say, we are creating a list of ingredients for \ud83c\udf4blemon tea and \ud83e\udedaginger tea. Trust me, the \u2615tea and this example are both effective. Since both of them have common ingredients we proceed in this way: Create a list named tea with all common ingredients Copy the list to a new name called lemon_tea Add lemon to the lemon_tea list Copy tea to a new name called ginger_tea Add ginger to the ginger_tea list I have given the exact sequence of steps because, in the process of creating tea , we would end up in a spaghetti\ud83c\udf5c Lets do it in code \ud83d\udc49\ud83c\udffb tea = [\"Milk\", \"Sugar\", \"Tea Powder\"] # Lemon Tea lemon_tea = tea lemon_tea.append(\"Lemon\") # Ginger Tea ginger_tea = tea ginger_tea.append(\"Ginger\") # Print results print(tea) print(lemon_tea) print(ginger_tea) # Output to show from the code return 0 ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] Notice how insertions happened in all the lists. Now, that's a big mixup. Lets take a closer look why it happened","title":"Copying in Python (WIP)"},{"location":"2026_02_26/#copying-in-python-wip","text":"","title":"Copying in Python (WIP)"},{"location":"2026_02_26/#motivation","text":"Lets say, we are creating a list of ingredients for \ud83c\udf4blemon tea and \ud83e\udedaginger tea. Trust me, the \u2615tea and this example are both effective. Since both of them have common ingredients we proceed in this way: Create a list named tea with all common ingredients Copy the list to a new name called lemon_tea Add lemon to the lemon_tea list Copy tea to a new name called ginger_tea Add ginger to the ginger_tea list I have given the exact sequence of steps because, in the process of creating tea , we would end up in a spaghetti\ud83c\udf5c Lets do it in code \ud83d\udc49\ud83c\udffb tea = [\"Milk\", \"Sugar\", \"Tea Powder\"] # Lemon Tea lemon_tea = tea lemon_tea.append(\"Lemon\") # Ginger Tea ginger_tea = tea ginger_tea.append(\"Ginger\") # Print results print(tea) print(lemon_tea) print(ginger_tea) # Output to show from the code return 0 ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] Notice how insertions happened in all the lists. Now, that's a big mixup. Lets take a closer look why it happened","title":"Motivation \ud83d\udcaa\ud83c\udffb"},{"location":"2026_02_28/","text":"Tuples are lighter than a list Motivation We all know the existence of the list data type in python. Then why invent the tuple ? Oh, because its lighter\u2696\ufe0f than a list. If tuples are lighter then why use lists at all. Because they are mutable. Why don't we have both characteristics in a single data type\ud83e\udd26\ud83c\udffb\u200d\u2642\ufe0f. To understand this, let's see how data is stored in them The mechanism of storage When we think of a list/tuple, let's call it a collection to avoid confusion, we think how ordered it is, and we naturally assume that data is arranged that way in memory. But that is inaccurate. A collection can hold different datatype and more importantly, different sizes of data. To bring this into perspective, imagine storing information of an email Sample email\u2709\ufe0f data: Sender\ud83e\uddd4\ud83c\udffb\u200d\u2642\ufe0f address = 30 chars recipient\ud83d\udc76\ud83c\udffb address = 40 chars subject = 80 chars body\ud83d\udcc3 = 160 chars Well, we could expand subject from 80 to 100 chars and observe what's gonna happen \ud83d\udca5... But that's not a discussion for now. Now let's say we edited the subject and made it 40 chars. Then there would be a gap in between the start addresses If the gap is to be, then why store data that way. Instead a collection stores the address of data in a sequence. The data can be stored anywhere else in the memory. Only the sequence needs to be in the correct order inside the collection Lists are mutable If a list has 4 elements to store, then we don;t exactly create 4 address boxes. Because, imagine a scenario where we found a compact space in memory, that can fit exactly 4 boxes. If something were to be appended to the list, then python needs to copy the addresses to a new location where it can put 5 addresses. This is kind of like moving the house\ud83c\udfe0 whenever you run out of space. This moving of house is a costly operation. You wanna do it, when you only really wanna do it. Naturally, you would choose a house with extra space in it Hence, a list always creates more address boxes than necessary. This extra rooms in the house (anticipating more luggage) costs us more memory. And because a tuple does not has .append() it would create the exact number of boxes So, now you know why. Let's really drive the point home using a code block import sys # Create a list and a tuple with the same elements my_collection = list(range(100)) my_list = list(my_collection) my_tuple = tuple(my_collection) # Get sizes in bytes list_size = sys.getsizeof(my_list) tuple_size = sys.getsizeof(my_tuple) print(f\"List size (100 elements): {list_size} bytes\") print(f\"Tuple size (100 elements): {tuple_size} bytes\") print(f\"Difference: {list_size - tuple_size} bytes\") # Output List size (100 elements): 856 bytes Tuple size (100 elements): 848 bytes Difference: 8 bytes","title":"Tuples are lighter than a list"},{"location":"2026_02_28/#tuples-are-lighter-than-a-list","text":"","title":"Tuples are lighter than a list"},{"location":"2026_02_28/#motivation","text":"We all know the existence of the list data type in python. Then why invent the tuple ? Oh, because its lighter\u2696\ufe0f than a list. If tuples are lighter then why use lists at all. Because they are mutable. Why don't we have both characteristics in a single data type\ud83e\udd26\ud83c\udffb\u200d\u2642\ufe0f. To understand this, let's see how data is stored in them","title":"Motivation"},{"location":"2026_02_28/#the-mechanism-of-storage","text":"When we think of a list/tuple, let's call it a collection to avoid confusion, we think how ordered it is, and we naturally assume that data is arranged that way in memory. But that is inaccurate. A collection can hold different datatype and more importantly, different sizes of data. To bring this into perspective, imagine storing information of an email Sample email\u2709\ufe0f data: Sender\ud83e\uddd4\ud83c\udffb\u200d\u2642\ufe0f address = 30 chars recipient\ud83d\udc76\ud83c\udffb address = 40 chars subject = 80 chars body\ud83d\udcc3 = 160 chars Well, we could expand subject from 80 to 100 chars and observe what's gonna happen \ud83d\udca5... But that's not a discussion for now. Now let's say we edited the subject and made it 40 chars. Then there would be a gap in between the start addresses If the gap is to be, then why store data that way. Instead a collection stores the address of data in a sequence. The data can be stored anywhere else in the memory. Only the sequence needs to be in the correct order inside the collection","title":"The mechanism of storage"},{"location":"2026_02_28/#lists-are-mutable","text":"If a list has 4 elements to store, then we don;t exactly create 4 address boxes. Because, imagine a scenario where we found a compact space in memory, that can fit exactly 4 boxes. If something were to be appended to the list, then python needs to copy the addresses to a new location where it can put 5 addresses. This is kind of like moving the house\ud83c\udfe0 whenever you run out of space. This moving of house is a costly operation. You wanna do it, when you only really wanna do it. Naturally, you would choose a house with extra space in it Hence, a list always creates more address boxes than necessary. This extra rooms in the house (anticipating more luggage) costs us more memory. And because a tuple does not has .append() it would create the exact number of boxes So, now you know why. Let's really drive the point home using a code block import sys # Create a list and a tuple with the same elements my_collection = list(range(100)) my_list = list(my_collection) my_tuple = tuple(my_collection) # Get sizes in bytes list_size = sys.getsizeof(my_list) tuple_size = sys.getsizeof(my_tuple) print(f\"List size (100 elements): {list_size} bytes\") print(f\"Tuple size (100 elements): {tuple_size} bytes\") print(f\"Difference: {list_size - tuple_size} bytes\") # Output List size (100 elements): 856 bytes Tuple size (100 elements): 848 bytes Difference: 8 bytes","title":"Lists are mutable"}]}