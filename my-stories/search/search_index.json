{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"My Stories (Blog Home) Welcome! This is where code meets craft. While many developers stop at the \" how \"\ud83e\udd14, I'm obsessed with the \" why \"\ud83e\udd7a \u2014 and I've found that the best way to explain complex systems is to... well... show them\ud83d\udcbb I've always found that a good diagram\ud83d\udcca can do more than a wall\ud83e\uddf1 of text\ud83d\udcc4. Because I work with vector graphics, I aim to explain complex concepts using illustrations to make the details easier to follow. Whether you're here to solve a specific problem or just to see how things work under the hood, I hope these visual breakdowns help\ud83d\ude09 Useful links Portfolio Site \ud83e\uddd4\ud83c\udffb\u200d\u2642\ufe0f About \ud83d\udcdc Projects \ud83e\uddbe","title":"My Stories (Blog Home)"},{"location":"#my-stories-blog-home","text":"Welcome! This is where code meets craft. While many developers stop at the \" how \"\ud83e\udd14, I'm obsessed with the \" why \"\ud83e\udd7a \u2014 and I've found that the best way to explain complex systems is to... well... show them\ud83d\udcbb I've always found that a good diagram\ud83d\udcca can do more than a wall\ud83e\uddf1 of text\ud83d\udcc4. Because I work with vector graphics, I aim to explain complex concepts using illustrations to make the details easier to follow. Whether you're here to solve a specific problem or just to see how things work under the hood, I hope these visual breakdowns help\ud83d\ude09","title":"My Stories (Blog Home)"},{"location":"#useful-links","text":"Portfolio Site \ud83e\uddd4\ud83c\udffb\u200d\u2642\ufe0f About \ud83d\udcdc Projects \ud83e\uddbe","title":"Useful links"},{"location":"Python/2026_02_26/","text":"Copying in Python (WIP) Motivation \ud83d\udcaa\ud83c\udffb Lets say, we are creating a list of ingredients for \ud83c\udf4blemon tea and \ud83e\udedaginger tea. Trust me, the \u2615tea and this example are both effective. Since both of them have common ingredients we proceed in this way: Create a list named tea with all common ingredients Copy the list to a new name called lemon_tea Add lemon to the lemon_tea list Copy tea to a new name called ginger_tea Add ginger to the ginger_tea list I have given the exact sequence of steps because, in the process of creating tea , we would end up in a spaghetti\ud83c\udf5c Lets do it in code \ud83d\udc49\ud83c\udffb tea = [\"Milk\", \"Sugar\", \"Tea Powder\"] # Lemon Tea lemon_tea = tea lemon_tea.append(\"Lemon\") # Ginger Tea ginger_tea = tea ginger_tea.append(\"Ginger\") # Print results print(tea) print(lemon_tea) print(ginger_tea) # Output to show from the code return 0 ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] Notice how insertions happened in all the lists. Now, that's a big mixup. Lets take a closer look why it happened","title":"Copying in Python (WIP)"},{"location":"Python/2026_02_26/#copying-in-python-wip","text":"","title":"Copying in Python (WIP)"},{"location":"Python/2026_02_26/#motivation","text":"Lets say, we are creating a list of ingredients for \ud83c\udf4blemon tea and \ud83e\udedaginger tea. Trust me, the \u2615tea and this example are both effective. Since both of them have common ingredients we proceed in this way: Create a list named tea with all common ingredients Copy the list to a new name called lemon_tea Add lemon to the lemon_tea list Copy tea to a new name called ginger_tea Add ginger to the ginger_tea list I have given the exact sequence of steps because, in the process of creating tea , we would end up in a spaghetti\ud83c\udf5c Lets do it in code \ud83d\udc49\ud83c\udffb tea = [\"Milk\", \"Sugar\", \"Tea Powder\"] # Lemon Tea lemon_tea = tea lemon_tea.append(\"Lemon\") # Ginger Tea ginger_tea = tea ginger_tea.append(\"Ginger\") # Print results print(tea) print(lemon_tea) print(ginger_tea) # Output to show from the code return 0 ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] Notice how insertions happened in all the lists. Now, that's a big mixup. Lets take a closer look why it happened","title":"Motivation \ud83d\udcaa\ud83c\udffb"},{"location":"Python/2026_02_28/","text":"Tuples are lighter than a list Motivation We all know the existence of the list data type in python. Then why invent the tuple ? Oh, because its lighter\u2696\ufe0f than a list. If tuples are lighter then why use lists at all. Because they are mutable. Why don't we have both characteristics in a single data type\ud83e\udd26\ud83c\udffb\u200d\u2642\ufe0f. To understand this, let's see how data is stored in them The mechanism of storage When we think of a list/tuple, let's call it a collection to avoid confusion, we think how ordered it is, and we naturally assume that data is arranged that way in memory. But that is inaccurate. A collection can hold different datatype and more importantly, different sizes of data. To bring this into perspective, imagine storing information of an email Sample email\u2709\ufe0f data: Sender\ud83e\uddd4\ud83c\udffb\u200d\u2642\ufe0f address = 30 chars recipient\ud83d\udc76\ud83c\udffb address = 40 chars subject = 80 chars body\ud83d\udcc3 = 160 chars Well, we could expand subject from 80 to 100 chars and observe what's gonna happen \ud83d\udca5... But that's not a discussion for now. Now let's say we edited the subject and made it 40 chars. Then there would be a gap in between the start addresses If the gap is to be, then why store data that way. Instead a collection stores the address of data in a sequence. The data can be stored anywhere else in the memory. Only the sequence needs to be in the correct order inside the collection Lists are mutable If a list has 4 elements to store, then we don;t exactly create 4 address boxes. Because, imagine a scenario where we found a compact space in memory, that can fit exactly 4 boxes. If something were to be appended to the list, then python needs to copy the addresses to a new location where it can put 5 addresses. This is kind of like moving the house\ud83c\udfe0 whenever you run out of space. This moving of house is a costly operation. You wanna do it, when you only really wanna do it. Naturally, you would choose a house with extra space in it Hence, a list always creates more address boxes than necessary. This extra rooms in the house (anticipating more luggage) costs us more memory. And because a tuple does not has .append() it would create the exact number of boxes So, now you know why. Let's really drive the point home using a code block import sys # Create a list and a tuple with the same elements my_collection = list(range(100)) my_list = list(my_collection) my_tuple = tuple(my_collection) # Get sizes in bytes list_size = sys.getsizeof(my_list) tuple_size = sys.getsizeof(my_tuple) print(f\"List size (100 elements): {list_size} bytes\") print(f\"Tuple size (100 elements): {tuple_size} bytes\") print(f\"Difference: {list_size - tuple_size} bytes\") # Output List size (100 elements): 856 bytes Tuple size (100 elements): 848 bytes Difference: 8 bytes","title":"Tuples are lighter than a list"},{"location":"Python/2026_02_28/#tuples-are-lighter-than-a-list","text":"","title":"Tuples are lighter than a list"},{"location":"Python/2026_02_28/#motivation","text":"We all know the existence of the list data type in python. Then why invent the tuple ? Oh, because its lighter\u2696\ufe0f than a list. If tuples are lighter then why use lists at all. Because they are mutable. Why don't we have both characteristics in a single data type\ud83e\udd26\ud83c\udffb\u200d\u2642\ufe0f. To understand this, let's see how data is stored in them","title":"Motivation"},{"location":"Python/2026_02_28/#the-mechanism-of-storage","text":"When we think of a list/tuple, let's call it a collection to avoid confusion, we think how ordered it is, and we naturally assume that data is arranged that way in memory. But that is inaccurate. A collection can hold different datatype and more importantly, different sizes of data. To bring this into perspective, imagine storing information of an email Sample email\u2709\ufe0f data: Sender\ud83e\uddd4\ud83c\udffb\u200d\u2642\ufe0f address = 30 chars recipient\ud83d\udc76\ud83c\udffb address = 40 chars subject = 80 chars body\ud83d\udcc3 = 160 chars Well, we could expand subject from 80 to 100 chars and observe what's gonna happen \ud83d\udca5... But that's not a discussion for now. Now let's say we edited the subject and made it 40 chars. Then there would be a gap in between the start addresses If the gap is to be, then why store data that way. Instead a collection stores the address of data in a sequence. The data can be stored anywhere else in the memory. Only the sequence needs to be in the correct order inside the collection","title":"The mechanism of storage"},{"location":"Python/2026_02_28/#lists-are-mutable","text":"If a list has 4 elements to store, then we don;t exactly create 4 address boxes. Because, imagine a scenario where we found a compact space in memory, that can fit exactly 4 boxes. If something were to be appended to the list, then python needs to copy the addresses to a new location where it can put 5 addresses. This is kind of like moving the house\ud83c\udfe0 whenever you run out of space. This moving of house is a costly operation. You wanna do it, when you only really wanna do it. Naturally, you would choose a house with extra space in it Hence, a list always creates more address boxes than necessary. This extra rooms in the house (anticipating more luggage) costs us more memory. And because a tuple does not has .append() it would create the exact number of boxes So, now you know why. Let's really drive the point home using a code block import sys # Create a list and a tuple with the same elements my_collection = list(range(100)) my_list = list(my_collection) my_tuple = tuple(my_collection) # Get sizes in bytes list_size = sys.getsizeof(my_list) tuple_size = sys.getsizeof(my_tuple) print(f\"List size (100 elements): {list_size} bytes\") print(f\"Tuple size (100 elements): {tuple_size} bytes\") print(f\"Difference: {list_size - tuple_size} bytes\") # Output List size (100 elements): 856 bytes Tuple size (100 elements): 848 bytes Difference: 8 bytes","title":"Lists are mutable"},{"location":"SQL/2026_03_07/","text":"Ranking in SQL The Ordering Lets get a table with some data. Imagine a table of revenue\ud83d\udcb5 generated by each sales representative\ud83d\udc54. We want to find the top performers\ud83c\udf1f Id Team Name Revenue 101 Angel's Wings Abraham 6005 102 Boosters John 5611 103 Devil's Cry Helena 8461 104 Redemption Kate 8180 105 Angel's Wings Jacob 9327 106 Devil's Cry Mary 8461 107 Boosters Menalaus 8461 108 Redemption Adam 8461 109 Redemption Noah 7483 110 Devil's Cry Jenny 6000 SELECT Id, Name, Revenue FROM salesData_tbl ORDER BY Revenue DESC; The default ordering in SQL is ascending (keyword: ASC ). To get descending we used the DESC Professionally, its better to be explicit and mention ASC (even if its default) to avoid confusion while understanding the code To, us the result looks something like this: Id Team Name Revenue 105 Angel's Wings Jacob 9327 103 Devil's Cry Helena 8461 106 Devil's Cry Mary 8461 107 Boosters Menalaus 8461 108 Redemption Adam 8461 104 Redemption Kate 8180 109 Redemption Noah 7483 101 Angel's Wings Abraham 6005 110 Devil's Cry Jenny 6000 102 Boosters John 5611 The ranking What we did above is sufficient for cases like getting the top performer. In many cases people end up doing ranking. While it has its use cases, it is not necessary right now Then, when is it necessary\ud83e\udd14? We have 3 different window functions in SQL for ranking. They are: Row number Rank Dense Rank Most practically, we use Row number in Data engineering to remove duplicates, so you might have heard and used it before\ud83d\ude03. But today, we shall explore where to use all of them But before that, lets actually look at what they do to avoid confusion and a side-by-side comparison. So, lets run the query: SELECT Id, Name, Revenue, ROW_NUMBER() OVER (ORDER BY Revenue Desc) as RowNum, RANK() OVER (ORDER BY Revenue Desc) as Rnk, DENSE_RANK() OVER (ORDER BY Revenue Desc) as DRnk FROM salesData_tbl; Notice how we didn't specify the ORDER BY Revenue in the end because its part of window function syntax Id Team Name Revenue RowNum Rnk Drnk 105 Angel's Wings Jacob 9327 1 1 1 103 Devil's Cry Helena 8461 2 2 2 106 Devil's Cry Mary 8461 3 2 2 107 Boosters Menalaus 8461 4 2 2 108 Redemption Adam 8461 5 2 2 104 Redemption Kate 8180 6 6 3 109 Redemption Noah 7483 7 7 4 101 Angel's Wings Abraham 6005 8 8 5 110 Devil's Cry Jenny 6000 9 9 6 102 Boosters John 5611 10 10 7 The real deal is when there is a tie. Obviously, there is a tie between Helena, Mary, Menalaus and Adam Row Number Row number ensures that it does not contain a duplicate value. So, when there is a tie among them, it puts the tied people in random order If we want a specific order for tied people we can do that as ROW_NUMBER() OVER (ORDER BY Revenue DESC, Id ASC) Imagine a scenario where I held this as an examination/interview and these are their scores. I want to select 4 people for my company\ud83c\udfed. Row number does the job perfect for me Rank Rank is used to find how many people are better than you. Suppose, Kate wants to login and see how many people out-performed her. Since, her rank is 6 it means 5 people out-performed her. Similarly for Menalaus at rank 2, 1 person out performed him Dense Rank Dense rank does not leave gaps in between because someone tied above you. It is not as ruthless as Rank Suppose I am giving bonus to TOP 3 performers. Using row number means injustice to Menalaus, Adam and Kate. Using rank means injustice to Kate. Enter Dense rank and it fixes everything Catch the duplicates So, now you know how and where to use ranking in SQL More commonly we see row number in our code. It's most commonly used to remove duplicates in Data Engineering. Imagine you are tracking the log-ins and log-outs of employees. You want to see if there are any duplicates in the table (it shouldn't. Otherwise you are wasting your storage for nothing). To keep it simple, lets say there is only 1 employee Id Action Time 101 In 10:01 101 Out 12:07 101 In 12:49 101 Out 17:57 101 In 18:09 101 Out 18:32 101 Out 18:32 101 Out 18:32 Now, its acceptable for a person to log out and log back in for some left over task. But the last 3 entries are true duplicates . To automatically find such entries we can run the query SELECT *, ROW_NUMBER() OVER (ORDER BY Time Desc) as RowNum FROM logs_tbl WHERE Action = 'Out'; Its a bit unfair we knew before hand that the duplicates are in Action = 'Out' . But bear with me ... Id Action Time RowNum 101 Out 18:32 1 101 Out 18:32 2 101 Out 18:32 3 101 Out 17:57 4 101 Out 12:07 5 And for the magic\ud83e\ude84, we add PARTITION BY . Partition... well makes partitions based on a criteria. Here we want to create a partition/compartment of particular times SELECT *, ROW_NUMBER() OVER ( PARTITION BY Time ORDER BY Time Desc ) as RowNum FROM logs_tbl WHERE Action = 'Out'; Id Action Time RowNum 101 Out 18:32 1 101 Out 18:32 2 101 Out 18:32 3 101 Out 17:57 1 101 Out 12:07 1 Hence, if we find any row number > 1, it means that the table has duplicates. As for the reason why I chose Action = 'Out' (even though in this case it makes no difference), is to ensure I don't catch cases where the person logs in and logs out within the minute. In that case, the system would have noted down the same time for both log in and log out, and this would have shown up as duplicate The Partitioning Since, you already learnt partitioning above, it does not require another introduction. Remember the very first table, with all the crazy team names. Imagine, you want the best performer from each team to be made the captain\ud83e\udd20 or something... In this case we can use partition on the team name SELECT Id, Name, Revenue, ROW_NUMBER() OVER ( PARTITION BY Team ORDER BY Revenue Desc ) as RowNum FROM salesData_tbl; Id Team Name Revenue RowNum 105 Angel's Wings Jacob 9327 1 101 Angel's Wings Abraham 6005 2 103 Devil's Cry Helena 8461 1 106 Devil's Cry Mary 8461 2 110 Devil's Cry Jenny 6000 3 107 Boosters Menalaus 8461 1 102 Boosters John 5611 2 108 Redemption Adam 8461 1 104 Redemption Kate 8180 2 109 Redemption Noah 7483 3 So, in Devil's Cry, even though Helena and Mary were tied, Helena got the captaincy\ud83e\udd20","title":"Ranking in SQL"},{"location":"SQL/2026_03_07/#ranking-in-sql","text":"","title":"Ranking in SQL"},{"location":"SQL/2026_03_07/#the-ordering","text":"Lets get a table with some data. Imagine a table of revenue\ud83d\udcb5 generated by each sales representative\ud83d\udc54. We want to find the top performers\ud83c\udf1f Id Team Name Revenue 101 Angel's Wings Abraham 6005 102 Boosters John 5611 103 Devil's Cry Helena 8461 104 Redemption Kate 8180 105 Angel's Wings Jacob 9327 106 Devil's Cry Mary 8461 107 Boosters Menalaus 8461 108 Redemption Adam 8461 109 Redemption Noah 7483 110 Devil's Cry Jenny 6000 SELECT Id, Name, Revenue FROM salesData_tbl ORDER BY Revenue DESC; The default ordering in SQL is ascending (keyword: ASC ). To get descending we used the DESC Professionally, its better to be explicit and mention ASC (even if its default) to avoid confusion while understanding the code To, us the result looks something like this: Id Team Name Revenue 105 Angel's Wings Jacob 9327 103 Devil's Cry Helena 8461 106 Devil's Cry Mary 8461 107 Boosters Menalaus 8461 108 Redemption Adam 8461 104 Redemption Kate 8180 109 Redemption Noah 7483 101 Angel's Wings Abraham 6005 110 Devil's Cry Jenny 6000 102 Boosters John 5611","title":"The Ordering"},{"location":"SQL/2026_03_07/#the-ranking","text":"What we did above is sufficient for cases like getting the top performer. In many cases people end up doing ranking. While it has its use cases, it is not necessary right now Then, when is it necessary\ud83e\udd14? We have 3 different window functions in SQL for ranking. They are: Row number Rank Dense Rank Most practically, we use Row number in Data engineering to remove duplicates, so you might have heard and used it before\ud83d\ude03. But today, we shall explore where to use all of them But before that, lets actually look at what they do to avoid confusion and a side-by-side comparison. So, lets run the query: SELECT Id, Name, Revenue, ROW_NUMBER() OVER (ORDER BY Revenue Desc) as RowNum, RANK() OVER (ORDER BY Revenue Desc) as Rnk, DENSE_RANK() OVER (ORDER BY Revenue Desc) as DRnk FROM salesData_tbl; Notice how we didn't specify the ORDER BY Revenue in the end because its part of window function syntax Id Team Name Revenue RowNum Rnk Drnk 105 Angel's Wings Jacob 9327 1 1 1 103 Devil's Cry Helena 8461 2 2 2 106 Devil's Cry Mary 8461 3 2 2 107 Boosters Menalaus 8461 4 2 2 108 Redemption Adam 8461 5 2 2 104 Redemption Kate 8180 6 6 3 109 Redemption Noah 7483 7 7 4 101 Angel's Wings Abraham 6005 8 8 5 110 Devil's Cry Jenny 6000 9 9 6 102 Boosters John 5611 10 10 7 The real deal is when there is a tie. Obviously, there is a tie between Helena, Mary, Menalaus and Adam","title":"The ranking"},{"location":"SQL/2026_03_07/#row-number","text":"Row number ensures that it does not contain a duplicate value. So, when there is a tie among them, it puts the tied people in random order If we want a specific order for tied people we can do that as ROW_NUMBER() OVER (ORDER BY Revenue DESC, Id ASC) Imagine a scenario where I held this as an examination/interview and these are their scores. I want to select 4 people for my company\ud83c\udfed. Row number does the job perfect for me","title":"Row Number"},{"location":"SQL/2026_03_07/#rank","text":"Rank is used to find how many people are better than you. Suppose, Kate wants to login and see how many people out-performed her. Since, her rank is 6 it means 5 people out-performed her. Similarly for Menalaus at rank 2, 1 person out performed him","title":"Rank"},{"location":"SQL/2026_03_07/#dense-rank","text":"Dense rank does not leave gaps in between because someone tied above you. It is not as ruthless as Rank Suppose I am giving bonus to TOP 3 performers. Using row number means injustice to Menalaus, Adam and Kate. Using rank means injustice to Kate. Enter Dense rank and it fixes everything","title":"Dense Rank"},{"location":"SQL/2026_03_07/#catch-the-duplicates","text":"So, now you know how and where to use ranking in SQL More commonly we see row number in our code. It's most commonly used to remove duplicates in Data Engineering. Imagine you are tracking the log-ins and log-outs of employees. You want to see if there are any duplicates in the table (it shouldn't. Otherwise you are wasting your storage for nothing). To keep it simple, lets say there is only 1 employee Id Action Time 101 In 10:01 101 Out 12:07 101 In 12:49 101 Out 17:57 101 In 18:09 101 Out 18:32 101 Out 18:32 101 Out 18:32 Now, its acceptable for a person to log out and log back in for some left over task. But the last 3 entries are true duplicates . To automatically find such entries we can run the query SELECT *, ROW_NUMBER() OVER (ORDER BY Time Desc) as RowNum FROM logs_tbl WHERE Action = 'Out'; Its a bit unfair we knew before hand that the duplicates are in Action = 'Out' . But bear with me ... Id Action Time RowNum 101 Out 18:32 1 101 Out 18:32 2 101 Out 18:32 3 101 Out 17:57 4 101 Out 12:07 5 And for the magic\ud83e\ude84, we add PARTITION BY . Partition... well makes partitions based on a criteria. Here we want to create a partition/compartment of particular times SELECT *, ROW_NUMBER() OVER ( PARTITION BY Time ORDER BY Time Desc ) as RowNum FROM logs_tbl WHERE Action = 'Out'; Id Action Time RowNum 101 Out 18:32 1 101 Out 18:32 2 101 Out 18:32 3 101 Out 17:57 1 101 Out 12:07 1 Hence, if we find any row number > 1, it means that the table has duplicates. As for the reason why I chose Action = 'Out' (even though in this case it makes no difference), is to ensure I don't catch cases where the person logs in and logs out within the minute. In that case, the system would have noted down the same time for both log in and log out, and this would have shown up as duplicate","title":"Catch the duplicates"},{"location":"SQL/2026_03_07/#the-partitioning","text":"Since, you already learnt partitioning above, it does not require another introduction. Remember the very first table, with all the crazy team names. Imagine, you want the best performer from each team to be made the captain\ud83e\udd20 or something... In this case we can use partition on the team name SELECT Id, Name, Revenue, ROW_NUMBER() OVER ( PARTITION BY Team ORDER BY Revenue Desc ) as RowNum FROM salesData_tbl; Id Team Name Revenue RowNum 105 Angel's Wings Jacob 9327 1 101 Angel's Wings Abraham 6005 2 103 Devil's Cry Helena 8461 1 106 Devil's Cry Mary 8461 2 110 Devil's Cry Jenny 6000 3 107 Boosters Menalaus 8461 1 102 Boosters John 5611 2 108 Redemption Adam 8461 1 104 Redemption Kate 8180 2 109 Redemption Noah 7483 3 So, in Devil's Cry, even though Helena and Mary were tied, Helena got the captaincy\ud83e\udd20","title":"The Partitioning"}]}