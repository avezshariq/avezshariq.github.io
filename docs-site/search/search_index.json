{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs (WIP) For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Mastering the Command Line \ud83d\ude80 In this post, we'll look at how to manage files across different systems. \ud83d\udca1 Quick Tip ??? note \"Why use the terminal?\" The terminal allows you to automate repetitive tasks that would take hours to do manually in a folder window. Step 1: Check your version Use the following command to see if you have Python installed. === \"Windows\" powershell linenums=\"1\" python --version === \"Mac/Linux\" bash linenums=\"1\" python3 --version Step 2: Useful Shortcuts To quickly clear your screen, press ++ctrl+l++. To exit the terminal, use ++ctrl+d++. Project Roadmap [x] Install MkDocs [x] Configure PyMdown Extensions [ ] Write first 10 blog posts [ ] Deploy to GitHub Pages Check out my GitHub at https://github.com/avezshariq (auto-linked!).","title":"Welcome to MkDocs (WIP)"},{"location":"#welcome-to-mkdocs-wip","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs (WIP)"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"#mastering-the-command-line","text":"In this post, we'll look at how to manage files across different systems.","title":"Mastering the Command Line \ud83d\ude80"},{"location":"#quick-tip","text":"??? note \"Why use the terminal?\" The terminal allows you to automate repetitive tasks that would take hours to do manually in a folder window.","title":"\ud83d\udca1 Quick Tip"},{"location":"#step-1-check-your-version","text":"Use the following command to see if you have Python installed. === \"Windows\" powershell linenums=\"1\" python --version === \"Mac/Linux\" bash linenums=\"1\" python3 --version","title":"Step 1: Check your version"},{"location":"#step-2-useful-shortcuts","text":"To quickly clear your screen, press ++ctrl+l++. To exit the terminal, use ++ctrl+d++.","title":"Step 2: Useful Shortcuts"},{"location":"#project-roadmap","text":"[x] Install MkDocs [x] Configure PyMdown Extensions [ ] Write first 10 blog posts [ ] Deploy to GitHub Pages Check out my GitHub at https://github.com/avezshariq (auto-linked!).","title":"Project Roadmap"},{"location":"2026_02_26/","text":"Copying in Python (WIP) Motivation \ud83d\udcaa\ud83c\udffb Lets say, we are creating a list of ingredients for \ud83c\udf4blemon tea and \ud83e\udedaginger tea. Trust me, the \u2615tea and this example are both effective. Since both of them have common ingredients we proceed in this way: Create a list named tea with all common ingredients Copy the list to a new name called lemon_tea Add lemon to the lemon_tea list Copy tea to a new name called ginger_tea Add ginger to the ginger_tea list I have given the exact sequence of steps because, in the process of creating tea , we would end up in a spaghetti\ud83c\udf5c Lets do it in code \ud83d\udc49\ud83c\udffb tea = [\"Milk\", \"Sugar\", \"Tea Powder\"] # Lemon Tea lemon_tea = tea lemon_tea.append(\"Lemon\") # Ginger Tea ginger_tea = tea ginger_tea.append(\"Ginger\") # Print results print(tea) print(lemon_tea) print(ginger_tea) # Output to show from the code return 0 ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] Notice how insertions happened in all the lists. Now, that's a big mixup. Lets take a closer look why it happened","title":"Copying in Python (WIP)"},{"location":"2026_02_26/#copying-in-python-wip","text":"","title":"Copying in Python (WIP)"},{"location":"2026_02_26/#motivation","text":"Lets say, we are creating a list of ingredients for \ud83c\udf4blemon tea and \ud83e\udedaginger tea. Trust me, the \u2615tea and this example are both effective. Since both of them have common ingredients we proceed in this way: Create a list named tea with all common ingredients Copy the list to a new name called lemon_tea Add lemon to the lemon_tea list Copy tea to a new name called ginger_tea Add ginger to the ginger_tea list I have given the exact sequence of steps because, in the process of creating tea , we would end up in a spaghetti\ud83c\udf5c Lets do it in code \ud83d\udc49\ud83c\udffb tea = [\"Milk\", \"Sugar\", \"Tea Powder\"] # Lemon Tea lemon_tea = tea lemon_tea.append(\"Lemon\") # Ginger Tea ginger_tea = tea ginger_tea.append(\"Ginger\") # Print results print(tea) print(lemon_tea) print(ginger_tea) # Output to show from the code return 0 ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] ['Milk', 'Sugar', 'Tea Powder', 'Lemon', 'Ginger'] Notice how insertions happened in all the lists. Now, that's a big mixup. Lets take a closer look why it happened","title":"Motivation \ud83d\udcaa\ud83c\udffb"},{"location":"2026_02_28/","text":"Tuples are lighter than a list Motivation We all know the existence of the list data type in python. Then why invent the tuple ? Oh, because its lighter\u2696\ufe0f than a list. If tuples are lighter then why use lists at all. Because they are mutable. Why don't we have both characteristics in a single data type\ud83e\udd26\ud83c\udffb\u200d\u2642\ufe0f. To understand this, lets see how data is stored in them The mechanism of storage When we think of a list/tuple, lets call it a collection to avoid confusion, we think how ordered it is, and we naturally assume that data is arranged that way in memory. But that is inaccurate. A collection can hold different datatype and more importantly, different sizes of data. To bring this into perspective, imagine storing information of an email Sample email\u2709\ufe0f data: Sender\ud83e\uddd4\ud83c\udffb\u200d\u2642\ufe0f address = 30 chars recipient\ud83d\udc76\ud83c\udffb address = 40 chars (assuming we are sending to only 1 person) subject\u2755 = 80 chars body\ud83d\udcc3 = 160 chars Well, we could expand subject from 80 to 100 chars and observe what's gonna happen \ud83d\udca5... But that's not a discussion for now. Now lets say we edited the subject and made it 40 chars. Then there would be a gap in between the start addresses If the gap is to be, then why store data that way. Instead a collection stores the address of data in a sequence. The data can be stored anywhere else in the memory. Only the sequence needs to be in the correct order inside the collection List are mutable If a list has 4 elements to store, then we don;t exactly create 4 address boxes. Because, imagine a scenario where we found a compact space in memory, that can fit exactly 4 boxes. If something were to be appended to the list, then python needs to copy the addresses to a new location where it can put 5 addresses. This is kind of like moving the house\ud83c\udfe0 whenever you run out of space. This moving of house is a costly operation. You wanna do it, when you only really wanna do it. Naturally, you would choose a house with extra space in it Hence, a list always creates more address boxes than necessary. This extra rooms in the house (anticipating more luggage) costs us more memory. And because a tuple does not has .append() it would create the exact number of boxes So, now you know why. Let's really drive the point home using a code block import sys # Create a list and a tuple with the same elements my_collection = list(range(100)) my_list = list(my_collection) my_tuple = tuple(my_collection) # Get sizes in bytes list_size = sys.getsizeof(my_list) tuple_size = sys.getsizeof(my_tuple) print(f\"List size (100 elements): {list_size} bytes\") print(f\"Tuple size (100 elements): {tuple_size} bytes\") print(f\"Difference: {list_size - tuple_size} bytes\") # Output List size (100 elements): 856 bytes Tuple size (100 elements): 848 bytes Difference: 8 bytes","title":"Tuples are lighter than a list"},{"location":"2026_02_28/#tuples-are-lighter-than-a-list","text":"","title":"Tuples are lighter than a list"},{"location":"2026_02_28/#motivation","text":"We all know the existence of the list data type in python. Then why invent the tuple ? Oh, because its lighter\u2696\ufe0f than a list. If tuples are lighter then why use lists at all. Because they are mutable. Why don't we have both characteristics in a single data type\ud83e\udd26\ud83c\udffb\u200d\u2642\ufe0f. To understand this, lets see how data is stored in them","title":"Motivation"},{"location":"2026_02_28/#the-mechanism-of-storage","text":"When we think of a list/tuple, lets call it a collection to avoid confusion, we think how ordered it is, and we naturally assume that data is arranged that way in memory. But that is inaccurate. A collection can hold different datatype and more importantly, different sizes of data. To bring this into perspective, imagine storing information of an email Sample email\u2709\ufe0f data: Sender\ud83e\uddd4\ud83c\udffb\u200d\u2642\ufe0f address = 30 chars recipient\ud83d\udc76\ud83c\udffb address = 40 chars (assuming we are sending to only 1 person) subject\u2755 = 80 chars body\ud83d\udcc3 = 160 chars Well, we could expand subject from 80 to 100 chars and observe what's gonna happen \ud83d\udca5... But that's not a discussion for now. Now lets say we edited the subject and made it 40 chars. Then there would be a gap in between the start addresses If the gap is to be, then why store data that way. Instead a collection stores the address of data in a sequence. The data can be stored anywhere else in the memory. Only the sequence needs to be in the correct order inside the collection","title":"The mechanism of storage"},{"location":"2026_02_28/#list-are-mutable","text":"If a list has 4 elements to store, then we don;t exactly create 4 address boxes. Because, imagine a scenario where we found a compact space in memory, that can fit exactly 4 boxes. If something were to be appended to the list, then python needs to copy the addresses to a new location where it can put 5 addresses. This is kind of like moving the house\ud83c\udfe0 whenever you run out of space. This moving of house is a costly operation. You wanna do it, when you only really wanna do it. Naturally, you would choose a house with extra space in it Hence, a list always creates more address boxes than necessary. This extra rooms in the house (anticipating more luggage) costs us more memory. And because a tuple does not has .append() it would create the exact number of boxes So, now you know why. Let's really drive the point home using a code block import sys # Create a list and a tuple with the same elements my_collection = list(range(100)) my_list = list(my_collection) my_tuple = tuple(my_collection) # Get sizes in bytes list_size = sys.getsizeof(my_list) tuple_size = sys.getsizeof(my_tuple) print(f\"List size (100 elements): {list_size} bytes\") print(f\"Tuple size (100 elements): {tuple_size} bytes\") print(f\"Difference: {list_size - tuple_size} bytes\") # Output List size (100 elements): 856 bytes Tuple size (100 elements): 848 bytes Difference: 8 bytes","title":"List are mutable"}]}